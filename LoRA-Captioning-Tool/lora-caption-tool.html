<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LoRA Caption Tool - AI-Powered Multi-Image Captioning</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2em;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1em;
        }

        .settings-panel {
            padding: 25px;
            background: #f8f9fa;
            border-bottom: 2px solid #e9ecef;
        }

        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .setting-group {
            display: flex;
            flex-direction: column;
        }

        .setting-group label {
            font-weight: 600;
            margin-bottom: 8px;
            color: #495057;
            font-size: 0.9em;
        }

        .setting-group input,
        .setting-group select,
        .setting-group textarea {
            padding: 10px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.2s;
        }

        .setting-group input:focus,
        .setting-group select:focus,
        .setting-group textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .bulk-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-success:hover {
            background: #218838;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .upload-zone {
            margin: 25px;
            padding: 60px;
            border: 3px dashed #dee2e6;
            border-radius: 12px;
            text-align: center;
            background: #f8f9fa;
            cursor: pointer;
            transition: all 0.3s;
        }

        .upload-zone:hover {
            border-color: #667eea;
            background: #e7f1ff;
        }

        .upload-zone.dragover {
            border-color: #667eea;
            background: #e7f1ff;
            transform: scale(1.02);
        }

        .upload-icon {
            font-size: 48px;
            margin-bottom: 15px;
        }

        .images-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            padding: 25px;
        }

        .image-card {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 12px;
            overflow: hidden;
            transition: all 0.2s;
        }

        .image-card:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            transform: translateY(-2px);
        }

        .image-preview {
            width: 100%;
            height: 250px;
            object-fit: cover;
            background: #f8f9fa;
        }

        .image-caption {
            padding: 15px;
        }

        .image-caption textarea {
            width: 100%;
            min-height: 180px;
            padding: 10px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            font-size: 13px;
            font-family: 'Courier New', monospace;
            resize: vertical;
            margin-bottom: 10px;
            line-height: 1.5;
        }

        .image-caption textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .image-actions {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }

        .image-actions button {
            flex: 1;
            padding: 8px;
            font-size: 12px;
        }

        .caption-info {
            font-size: 11px;
            color: #6c757d;
            margin-top: 5px;
        }

        .progress-bar {
            width: 100%;
            height: 4px;
            background: #e9ecef;
            border-radius: 2px;
            overflow: hidden;
            margin-top: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.3s;
        }

        .status-message {
            padding: 15px;
            margin: 20px 25px;
            border-radius: 8px;
            font-size: 14px;
            display: none;
        }

        .status-message.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .status-message.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status-message.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status-message.warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #6c757d;
        }

        .empty-state-icon {
            font-size: 64px;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        .export-method-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            margin-left: 8px;
        }

        .badge-recommended {
            background: #28a745;
            color: white;
        }

        .badge-warning {
            background: #ffc107;
            color: #000;
        }

        @media (max-width: 768px) {
            .settings-grid {
                grid-template-columns: 1fr;
            }
            
            .images-grid {
                grid-template-columns: 1fr;
            }

            .bulk-actions {
                flex-direction: column;
            }

            .btn {
                width: 100%;
            }
        }

        kbd {
            background: #f4f4f4;
            border: 1px solid #ccc;
            border-radius: 3px;
            padding: 2px 6px;
            font-family: monospace;
            font-size: 12px;
            box-shadow: 0 1px 0 rgba(0,0,0,0.2);
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 12px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
        }

        .modal-header {
            font-size: 1.5em;
            margin-bottom: 20px;
            color: #333;
        }

        .modal-body {
            margin-bottom: 20px;
            line-height: 1.6;
            color: #666;
        }

        .modal-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üé® LoRA Caption Tool</h1>
            <p>AI-Powered Multi-Image Captioning for Training Datasets</p>
        </div>

        <div class="status-message info" style="display: block; margin: 20px 25px;">
            <strong>üîí Privacy Notice:</strong> This tool runs entirely in your browser. No API keys, images, or captions are stored on any server. All data remains on your device. API keys are transmitted directly to your chosen AI provider (OpenRouter, OpenAI, or n8n) and are never saved or logged by this application.
        </div>

        <div class="settings-panel">
            <div class="settings-grid">
                <div class="setting-group">
                    <label for="apiProvider">AI Provider</label>
                    <select id="apiProvider">
                        <option value="openrouter">OpenRouter (Recommended)</option>
                        <option value="openai">OpenAI</option>
                        <option value="replicate">Replicate</option>
                        <option value="n8n">n8n Workflow</option>
                    </select>
                </div>

                <div class="setting-group" id="apiKeyGroup">
                    <label for="apiKey">API Key</label>
                    <input type="password" id="apiKey" placeholder="Enter your API key (sk-or-v1-...)">
                    <small style="color: #6c757d; margin-top: 5px; font-size: 12px;">
                        OpenRouter keys start with "sk-or-v1-" ‚Ä¢ Get yours at <a href="https://openrouter.ai/keys" target="_blank" style="color: #667eea;">openrouter.ai/keys</a>
                    </small>
                </div>

                <div class="setting-group" id="n8nUrlGroup" style="display: none;">
                    <label for="n8nUrl">n8n Webhook URL</label>
                    <input type="text" id="n8nUrl" placeholder="https://your-n8n-instance.com/webhook/...">
                </div>

                <div class="setting-group" id="n8nTokenGroup" style="display: none;">
                    <label for="n8nToken">Bearer Token</label>
                    <input type="password" id="n8nToken" placeholder="Enter your Bearer token">
                </div>

                <div class="setting-group" id="modelGroup">
                    <label for="model">Model</label>
                    <select id="model">
                        <option value="google/gemini-2.0-flash-001">Gemini 2.0 Flash</option>
                        <option value="openai/gpt-4o">GPT-4o</option>
                        <option value="anthropic/claude-3.5-sonnet">Claude 3.5 Sonnet</option>
                        <option value="meta-llama/llama-3.2-90b-vision-instruct">Llama 3.2 Vision</option>
                        <option value="qwen/qwen-2-vl-72b-instruct">Qwen 2 VL 72B</option>
                        <option value="custom">Custom Model...</option>
                    </select>
                </div>

                <div class="setting-group" id="customModelGroup" style="display: none;">
                    <label for="customModel">Custom Model Name</label>
                    <input type="text" id="customModel" placeholder="e.g., anthropic/claude-3-opus">
                    <small style="color: #6c757d; margin-top: 5px; font-size: 12px;">
                        Browse models at <a href="https://openrouter.ai/models" target="_blank" style="color: #667eea;">openrouter.ai/models</a>
                    </small>
                </div>

                <div class="setting-group">
                    <label for="captionStyle">Caption Style</label>
                    <select id="captionStyle">
                        <option value="natural">Structured Natural Language</option>
                        <option value="tags">Structured Danbooru Tags</option>
                        <option value="hybrid">Structured Hybrid (Desc + Tags)</option>
                    </select>
                </div>

                <div class="setting-group">
                    <label for="triggerWord">Trigger Word (Optional)</label>
                    <input type="text" id="triggerWord" placeholder="e.g., ohwx, mychar">
                </div>

                <div class="setting-group">
                    <label for="prefix">Caption Prefix (Optional)</label>
                    <input type="text" id="prefix" placeholder="e.g., masterpiece, best quality">
                </div>

                <div class="setting-group">
                    <label>Advanced</label>
                    <button class="btn btn-secondary" id="editPromptBtn" style="width: 100%;">
                        ‚öôÔ∏è Edit Prompt Template
                    </button>
                </div>
            </div>

            <div class="bulk-actions">
                <button class="btn btn-primary" id="captionAllBtn" disabled>
                    ‚ú® Caption All Images
                </button>
                <button class="btn btn-primary" id="recaptionAllBtn" disabled>
                    üîÑ Re-Caption All (Replace)
                </button>
                <button class="btn btn-secondary" id="applyPrefixBtn" disabled>
                    üìù Apply Prefix to All
                </button>
                <button class="btn btn-secondary" id="findReplaceBtn" disabled>
                    üîç Find & Replace
                </button>
                <button class="btn btn-success" id="exportFolderBtn" disabled>
                    üìÅ Save to Folder <span class="export-method-badge badge-recommended">NO WARNINGS</span>
                </button>
                <button class="btn btn-success" id="exportIndividualBtn" disabled>
                    üì¶ Download All Files
                </button>
                <button class="btn btn-secondary" id="exportZipBtn" disabled>
                    üíæ Export ZIP <span class="export-method-badge badge-warning">May Warn</span>
                </button>
                <button class="btn btn-secondary" id="clearAllBtn" disabled>
                    üóëÔ∏è Clear All
                </button>
            </div>

            <div class="progress-bar" id="progressBar" style="display: none;">
                <div class="progress-fill" id="progressFill"></div>
            </div>
        </div>

        <div class="status-message" id="statusMessage"></div>

        <div class="upload-zone" id="uploadZone">
            <div class="upload-icon">üì∏</div>
            <h3>Drop images here or click to upload</h3>
            <p style="margin-top: 10px; color: #6c757d;">Supports: JPG, PNG, WEBP ‚Ä¢ Multiple files</p>
            <input type="file" id="fileInput" multiple accept="image/*" style="display: none;">
            <div style="margin-top: 20px; padding-top: 20px; border-top: 2px dashed #dee2e6;">
                <button class="btn btn-secondary" id="importDatasetBtn" type="button">
                    üìÅ Import Existing Dataset (Images + Captions)
                </button>
                <p style="margin-top: 10px; color: #6c757d; font-size: 13px;">
                    üí° <strong>How to select:</strong> Use <kbd>Ctrl+A</kbd> (or <kbd>Cmd+A</kbd> on Mac) to select all files in your folder
                </p>
                <input type="file" id="datasetInput" multiple accept="*/*,.txt,.jpg,.jpeg,.png,.gif,.webp" style="display: none;">
            </div>
        </div>

        <div class="images-grid" id="imagesGrid"></div>

        <div class="empty-state" id="emptyState" style="display: none;">
            <div class="empty-state-icon">üñºÔ∏è</div>
            <h3>No images uploaded yet</h3>
            <p>Upload some images to get started with AI captioning</p>
        </div>
    </div>

    <!-- Legal and Privacy Notice -->
    <div style="max-width: 1400px; margin: 20px auto; padding: 20px; background: rgba(255,255,255,0.95); border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);">
        <h3 style="margin-bottom: 15px; color: #333;">¬© Copyright & License</h3>
        <div style="line-height: 1.8; color: #666; font-size: 14px; margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #667eea;">
            <p style="margin-bottom: 10px;"><strong>Copyright ¬© 2025. All Rights Reserved.</strong></p>
            
            <p style="margin-bottom: 10px;">This software and its user interface ("LoRA Caption Tool") are provided for <strong>personal, non-commercial use only</strong>. By using this tool, you agree to the following terms:</p>
            
            <p style="margin-bottom: 10px;"><strong>Permitted Uses:</strong></p>
            <ul style="margin-left: 30px; margin-bottom: 10px;">
                <li>Personal use for creating training datasets</li>
                <li>Educational purposes and learning</li>
                <li>Research and development projects</li>
                <li>Non-commercial hobby projects</li>
            </ul>
            
            <p style="margin-bottom: 10px;"><strong>Prohibited Uses:</strong></p>
            <ul style="margin-left: 30px; margin-bottom: 10px;">
                <li>Commercial use, sale, or redistribution of this software</li>
                <li>Sublicensing, renting, or leasing this software</li>
                <li>Modifying, reverse engineering, or creating derivative works</li>
                <li>Removing or altering copyright notices</li>
                <li>Using for commercial training dataset creation or sales</li>
                <li>Incorporating into commercial products or services</li>
            </ul>
            
            <p style="margin-bottom: 10px;"><strong>Intellectual Property:</strong> The design, code, user interface, and all associated materials are the exclusive property of the copyright holder. All rights not expressly granted herein are reserved.</p>
            
            <p style="margin-bottom: 0;"><strong>License Grant:</strong> A non-exclusive, non-transferable, revocable license is granted for personal use only. This license may be terminated at any time without notice.</p>
        </div>
        
        <h3 style="margin-bottom: 15px; color: #333;">üìã Privacy & Legal Information</h3>
        <div style="line-height: 1.8; color: #666; font-size: 14px;">
            <p style="margin-bottom: 10px;"><strong>üîí No Data Storage:</strong> This application is a client-side web tool that runs entirely in your browser. We do not store, log, or transmit any of your data to our servers.</p>
            
            <p style="margin-bottom: 10px;"><strong>üîë API Keys:</strong> API keys you enter are stored only in your browser's memory during your session and are never saved to disk, cookies, or any persistent storage. Keys are transmitted directly and exclusively to your selected AI provider's API endpoint.</p>
            
            <p style="margin-bottom: 10px;"><strong>üñºÔ∏è Image Data:</strong> Images you upload remain on your device. They are processed locally in your browser and only sent to your chosen AI provider (OpenRouter, OpenAI, or n8n) when you click the caption button.</p>
            
            <p style="margin-bottom: 10px;"><strong>üì§ Third-Party Services:</strong> When you use this tool, your images and prompts are sent to the AI provider you select. Please review their privacy policies:</p>
            <ul style="margin-left: 30px; margin-bottom: 10px;">
                <li>OpenRouter: <a href="https://openrouter.ai/privacy" target="_blank" style="color: #667eea;">openrouter.ai/privacy</a></li>
                <li>OpenAI: <a href="https://openai.com/privacy" target="_blank" style="color: #667eea;">openai.com/privacy</a></li>
                <li>n8n: Your self-hosted workflow (your responsibility)</li>
            </ul>
            
            <p style="margin-bottom: 10px;"><strong>‚öñÔ∏è Disclaimer of Warranties:</strong> This tool is provided "AS IS" and "AS AVAILABLE" without warranties of any kind, either express or implied, including but not limited to warranties of merchantability, fitness for a particular purpose, or non-infringement. The copyright holder makes no warranty that the software will be error-free, uninterrupted, secure, or free from viruses or other harmful components.</p>
            
            <p style="margin-bottom: 10px;"><strong>üìõ Limitation of Liability:</strong> In no event shall the copyright holder be liable for any direct, indirect, incidental, special, consequential, or punitive damages, including but not limited to loss of data, loss of profits, or business interruption, arising out of or related to your use or inability to use this software, even if advised of the possibility of such damages. Your use of third-party AI services is at your own risk.</p>
            
            <p style="margin-bottom: 10px;"><strong>üë§ User Responsibility:</strong> Users are solely responsible for ensuring their use complies with applicable laws, regulations, and the terms of service of third-party AI providers. Users are responsible for any costs incurred through API usage and for the content they create or process.</p>
            
            <p style="margin-bottom: 0;"><strong>üõ°Ô∏è Security Recommendation:</strong> Always use API keys with appropriate spending limits and permissions. Never share your API keys with others. Users are responsible for the security of their credentials.</p>
        </div>
    </div>

    <!-- Browser Compatibility Modal -->
    <div class="modal" id="compatModal">
        <div class="modal-content">
            <div class="modal-header">Export Method Not Supported</div>
            <div class="modal-body">
                <p>The "Save to Folder" feature requires a modern browser (Chrome 86+, Edge 86+).</p>
                <p style="margin-top: 15px;"><strong>Alternative options:</strong></p>
                <ul style="margin-top: 10px; margin-left: 20px;">
                    <li>Use "Download All Files" for individual downloads</li>
                    <li>Use "Export ZIP" (may trigger Windows security warning)</li>
                    <li>Update your browser to the latest version</li>
                </ul>
            </div>
            <div class="modal-actions">
                <button class="btn btn-primary" onclick="closeModal('compatModal')">Got it</button>
            </div>
        </div>
    </div>

    <!-- Prompt Editor Modal -->
    <div class="modal" id="promptModal">
        <div class="modal-content" style="max-width: 800px;">
            <div class="modal-header">Edit Prompt Template</div>
            <div class="modal-body">
                <p style="margin-bottom: 15px; color: #666;">Customize the prompt sent to the AI model. Use the variables below to maintain structured output.</p>
                
                <div style="margin-bottom: 20px;">
                    <label style="display: block; font-weight: 600; margin-bottom: 8px; color: #495057;">
                        Prompt Template for <span id="promptStyleLabel">Natural Language</span>:
                    </label>
                    <textarea id="promptEditor" style="width: 100%; min-height: 300px; padding: 15px; border: 2px solid #dee2e6; border-radius: 8px; font-family: 'Courier New', monospace; font-size: 13px; line-height: 1.6; resize: vertical;"></textarea>
                </div>

                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                    <strong style="color: #495057;">üí° Tips:</strong>
                    <ul style="margin: 10px 0 0 20px; color: #666; font-size: 13px; line-height: 1.8;">
                        <li>Keep the 8 field structure for consistency</li>
                        <li>Be clear and specific in your instructions</li>
                        <li>Test with a single image before batch captioning</li>
                        <li>Click "Reset to Default" to restore original prompt</li>
                    </ul>
                </div>
            </div>
            <div class="modal-actions">
                <button class="btn btn-secondary" id="resetPromptBtn">Reset to Default</button>
                <button class="btn btn-secondary" onclick="closeModal('promptModal')">Cancel</button>
                <button class="btn btn-primary" id="savePromptBtn">Save Changes</button>
            </div>
        </div>
    </div>

    <!-- Find & Replace Modal -->
    <div class="modal" id="findReplaceModal">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">Find & Replace in All Captions</div>
            <div class="modal-body">
                <div style="margin-bottom: 20px;">
                    <label style="display: block; font-weight: 600; margin-bottom: 8px; color: #495057;">
                        Find Text:
                    </label>
                    <input type="text" id="findText" placeholder="Text to find..." style="width: 100%; padding: 10px; border: 2px solid #dee2e6; border-radius: 8px; font-size: 14px;">
                </div>

                <div style="margin-bottom: 20px;">
                    <label style="display: block; font-weight: 600; margin-bottom: 8px; color: #495057;">
                        Replace With:
                    </label>
                    <input type="text" id="replaceText" placeholder="Replacement text..." style="width: 100%; padding: 10px; border: 2px solid #dee2e6; border-radius: 8px; font-size: 14px;">
                </div>

                <div style="margin-bottom: 15px;">
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="checkbox" id="caseSensitive" style="margin-right: 8px;">
                        <span style="color: #495057;">Case sensitive</span>
                    </label>
                </div>

                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px;">
                    <strong style="color: #495057;">üí° Examples:</strong>
                    <ul style="margin: 10px 0 0 20px; color: #666; font-size: 13px; line-height: 1.8;">
                        <li>Find: "1girl" ‚Üí Replace: "1woman" (update terminology)</li>
                        <li>Find: "standing" ‚Üí Replace: "standing, confident pose" (add details)</li>
                        <li>Find: ", , " ‚Üí Replace: ", " (clean up double commas)</li>
                    </ul>
                </div>
            </div>
            <div class="modal-actions">
                <button class="btn btn-secondary" onclick="closeModal('findReplaceModal')">Cancel</button>
                <button class="btn btn-primary" id="executeFindReplaceBtn">Replace All</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script>
        // State management
        const state = {
            images: [],
            processing: false,
            customPrompts: {
                natural: null,
                tags: null,
                hybrid: null
            }
        };

        // Default prompts (for reset functionality)
        const defaultPrompts = {
            natural: `You are a professional image captioning assistant helping create training data for machine learning models. Please analyze this image objectively and provide structured descriptive metadata.

Format your response exactly as follows:

Subject: [describe what/who is the main focus]
Appearance: [describe colors, features, visual characteristics]
Clothing: [describe any visible attire, accessories, or garments]
Pose: [describe body position, orientation, and any gestures]
Setting: [describe the environment, location, and background]
Lighting: [describe illumination, shadows, and atmospheric conditions]
Art Style: [describe the artistic medium, technique, and quality]
Notable Details: [describe any other significant visual elements]

Be thorough, objective, and professional in your descriptions. Write "none" for categories that don't apply to this image.`,
            
            tags: `You are a professional image captioning assistant for machine learning training datasets. Analyze this image objectively and provide descriptive metadata in a structured format.

Provide comma-separated descriptive tags for each category:

Subject: [main subject tags]
Appearance: [visual feature tags]
Clothing: [attire and accessory tags]
Pose: [position and gesture tags]
Setting: [environment and background tags]
Lighting: [illumination and atmosphere tags]
Art Style: [artistic technique and quality tags]
Notable Details: [additional noteworthy element tags]

Use lowercase tags with underscores. Write "none" if a category doesn't apply. Be objective and descriptive.`,
            
            hybrid: `You are a professional image captioning assistant for machine learning training datasets. Analyze this image objectively and provide descriptive metadata in a structured format.

Provide brief descriptions for each category:

Subject: [main subject description]
Appearance: [visual features description]
Clothing: [attire and accessories description]
Pose: [position and gesture description]
Setting: [environment and background description]
Lighting: [illumination and atmosphere description]
Art Style: [artistic technique and quality description]
Notable Details: [additional noteworthy elements description]

Be objective, detailed, and professional. Write "none" if a category doesn't apply.`
        };

        // DOM elements
        const uploadZone = document.getElementById('uploadZone');
        const fileInput = document.getElementById('fileInput');
        const datasetInput = document.getElementById('datasetInput');
        const importDatasetBtn = document.getElementById('importDatasetBtn');
        const imagesGrid = document.getElementById('imagesGrid');
        const emptyState = document.getElementById('emptyState');
        const statusMessage = document.getElementById('statusMessage');
        const progressBar = document.getElementById('progressBar');
        const progressFill = document.getElementById('progressFill');
        const apiProvider = document.getElementById('apiProvider');
        const apiKey = document.getElementById('apiKey');
        const model = document.getElementById('model');
        const customModel = document.getElementById('customModel');
        const customModelGroup = document.getElementById('customModelGroup');
        const captionStyle = document.getElementById('captionStyle');
        const triggerWord = document.getElementById('triggerWord');
        const prefix = document.getElementById('prefix');
        const n8nUrl = document.getElementById('n8nUrl');
        const n8nToken = document.getElementById('n8nToken');
        const apiKeyGroup = document.getElementById('apiKeyGroup');
        const n8nUrlGroup = document.getElementById('n8nUrlGroup');
        const n8nTokenGroup = document.getElementById('n8nTokenGroup');
        const modelGroup = document.getElementById('modelGroup');
        const compatModal = document.getElementById('compatModal');
        const promptModal = document.getElementById('promptModal');
        const promptEditor = document.getElementById('promptEditor');
        const promptStyleLabel = document.getElementById('promptStyleLabel');
        const editPromptBtn = document.getElementById('editPromptBtn');
        const savePromptBtn = document.getElementById('savePromptBtn');
        const resetPromptBtn = document.getElementById('resetPromptBtn');

        // Check browser support for File System Access API
        const supportsFileSystemAccess = 'showDirectoryPicker' in window;

        // Show/hide custom model input based on selection
        model.addEventListener('change', () => {
            if (model.value === 'custom') {
                customModelGroup.style.display = 'block';
            } else {
                customModelGroup.style.display = 'none';
            }
        });

        // Update model options based on provider
        apiProvider.addEventListener('change', () => {
            const provider = apiProvider.value;
            
            // Show/hide appropriate fields
            if (provider === 'n8n') {
                apiKeyGroup.style.display = 'none';
                modelGroup.style.display = 'none';
                customModelGroup.style.display = 'none';
                n8nUrlGroup.style.display = 'block';
                n8nTokenGroup.style.display = 'block';
            } else {
                apiKeyGroup.style.display = 'block';
                modelGroup.style.display = 'block';
                n8nUrlGroup.style.display = 'none';
                n8nTokenGroup.style.display = 'none';
                // Hide custom model by default when switching providers
                customModelGroup.style.display = 'none';
            }
            
            model.innerHTML = '';
            
            if (provider === 'openrouter') {
                model.innerHTML = `
                    <option value="google/gemini-2.0-flash-001">Gemini 2.0 Flash</option>
                    <option value="openai/gpt-4o">GPT-4o</option>
                    <option value="anthropic/claude-3.5-sonnet">Claude 3.5 Sonnet</option>
                    <option value="meta-llama/llama-3.2-90b-vision-instruct">Llama 3.2 Vision</option>
                    <option value="qwen/qwen-2-vl-72b-instruct">Qwen 2 VL 72B</option>
                    <option value="custom">Custom Model...</option>
                `;
            } else if (provider === 'openai') {
                model.innerHTML = `
                    <option value="gpt-4o">GPT-4o</option>
                    <option value="gpt-4o-mini">GPT-4o Mini</option>
                    <option value="gpt-4-turbo">GPT-4 Turbo</option>
                `;
            } else if (provider === 'replicate') {
                model.innerHTML = `
                    <option value="meta/meta-llama-3-2-90b-vision-instruct">Llama 3.2 Vision 90B</option>
                    <option value="yorickvp/llava-13b">LLaVA 13B</option>
                `;
            }
        });

        // File upload handlers
        uploadZone.addEventListener('click', (e) => {
            // Prevent triggering if clicking on the import button or anything inside it
            const importBtn = document.getElementById('importDatasetBtn');
            if (e.target === importBtn || importBtn.contains(e.target)) {
                return;
            }
            // Also check if click was on the description text below import button
            const clickedElement = e.target;
            const parent = clickedElement.parentElement;
            if (parent && parent.style && parent.style.borderTop) {
                return; // Clicked in the import section
            }
            fileInput.click();
        });
        fileInput.addEventListener('change', handleFiles);
        
        // Separate handler for import button - completely isolated
        importDatasetBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            console.log('Import button clicked');
            datasetInput.click();
        });
        
        // Single event listener for dataset input
        datasetInput.addEventListener('change', handleDatasetImport, { once: false });

        uploadZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadZone.classList.add('dragover');
        });

        uploadZone.addEventListener('dragleave', () => {
            uploadZone.classList.remove('dragover');
        });

        uploadZone.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadZone.classList.remove('dragover');
            handleFiles({ target: { files: e.dataTransfer.files } });
        });

        function handleFiles(e) {
            const files = Array.from(e.target.files);
            files.forEach(file => {
                if (file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const id = Date.now() + Math.random();
                        state.images.push({
                            id,
                            file,
                            dataUrl: event.target.result,
                            caption: '',
                            name: file.name
                        });
                        renderImages();
                    };
                    reader.readAsDataURL(file);
                }
            });
            fileInput.value = '';
        }

        async function handleDatasetImport(e) {
            const files = Array.from(e.target.files);
            
            console.log('handleDatasetImport called with', files.length, 'files');
            
            if (files.length === 0) {
                console.log('No files selected, returning');
                datasetInput.value = '';
                return;
            }

            showStatus('üì• Importing dataset...', 'info');
            
            // Filter files by extension
            const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp'];
            const imageFiles = files.filter(f => {
                const ext = f.name.toLowerCase().match(/\.[^.]+$/);
                return ext && imageExtensions.includes(ext[0]);
            });
            const textFiles = files.filter(f => f.name.toLowerCase().endsWith('.txt'));
            
            console.log('Found', imageFiles.length, 'images and', textFiles.length, 'txt files');
            
            if (imageFiles.length === 0) {
                showStatus('‚ö†Ô∏è No image files found. Please select image files (.jpg, .png, etc.)', 'warning');
                datasetInput.value = '';
                return;
            }
            
            // Create a map of text files by base name (case insensitive)
            const captionsMap = new Map();
            
            // Read all text files first - using Promise.all for synchronization
            console.log('Reading text files...');
            for (const txtFile of textFiles) {
                try {
                    const text = await readFileAsText(txtFile);
                    const baseName = txtFile.name.replace(/\.txt$/i, '').toLowerCase();
                    captionsMap.set(baseName, text);
                    console.log('Loaded caption for:', baseName);
                } catch (error) {
                    console.error('Error reading', txtFile.name, error);
                }
            }
            
            console.log('Caption map has', captionsMap.size, 'entries');
            
            // Now process images and match with captions
            console.log('Processing images...');
            let matched = 0;
            
            for (const file of imageFiles) {
                try {
                    const dataUrl = await readFileAsDataURL(file);
                    const id = Date.now() + Math.random();
                    
                    // Get base name without extension (case insensitive)
                    const baseName = file.name.replace(/\.[^/.]+$/, '').toLowerCase();
                    const caption = captionsMap.get(baseName) || '';
                    
                    if (caption) {
                        matched++;
                        console.log('Matched caption for:', file.name);
                    } else {
                        console.log('No caption for:', file.name);
                    }
                    
                    state.images.push({
                        id,
                        file,
                        dataUrl: dataUrl,
                        caption: caption,
                        name: file.name
                    });
                } catch (error) {
                    console.error('Error processing', file.name, error);
                }
            }
            
            console.log('Import complete. Matched:', matched, 'of', imageFiles.length);
            
            renderImages();
            datasetInput.value = ''; // Reset input
            
            const unmatched = imageFiles.length - matched;
            
            let message = `‚úÖ Imported ${imageFiles.length} images`;
            if (matched > 0) {
                message += `, ${matched} with captions`;
            }
            if (unmatched > 0) {
                message += `, ${unmatched} without captions`;
            }
            
            showStatus(message, 'success');
        }
        
        // Helper functions for file reading with proper error handling
        function readFileAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = (e) => reject(e);
                reader.readAsText(file);
            });
        }
        
        function readFileAsDataURL(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = (e) => reject(e);
                reader.readAsDataURL(file);
            });
        }

        function renderImages() {
            if (state.images.length === 0) {
                imagesGrid.innerHTML = '';
                emptyState.style.display = 'block';
                updateButtonStates();
                return;
            }

            emptyState.style.display = 'none';
            uploadZone.style.display = 'none';
            
            imagesGrid.innerHTML = state.images.map(img => `
                <div class="image-card" data-id="${img.id}">
                    <img src="${img.dataUrl}" class="image-preview" alt="${img.name}">
                    <div class="image-caption">
                        <textarea placeholder="Caption will appear here..." data-id="${img.id}">${img.caption}</textarea>
                        <div class="caption-info">
                            ${img.caption ? img.caption.length + ' characters' : 'No caption yet'}
                        </div>
                        <div class="image-actions">
                            <button class="btn btn-primary" onclick="captionSingle(${img.id})">‚ú® Caption</button>
                            <button class="btn btn-secondary" onclick="removeImage(${img.id})">üóëÔ∏è Remove</button>
                        </div>
                    </div>
                </div>
            `).join('');

            // Add event listeners to textareas
            document.querySelectorAll('textarea').forEach(textarea => {
                textarea.addEventListener('input', (e) => {
                    const id = parseFloat(e.target.dataset.id);
                    const image = state.images.find(img => img.id === id);
                    if (image) {
                        image.caption = e.target.value;
                        updateCaptionInfo(id);
                    }
                });
            });

            updateButtonStates();
        }

        function updateCaptionInfo(id) {
            const card = document.querySelector(`[data-id="${id}"]`);
            const image = state.images.find(img => img.id === id);
            const info = card.querySelector('.caption-info');
            info.textContent = image.caption ? image.caption.length + ' characters' : 'No caption yet';
        }

        function updateButtonStates() {
            const hasImages = state.images.length > 0;
            const hasCaptions = state.images.some(img => img.caption);
            
            document.getElementById('captionAllBtn').disabled = !hasImages || state.processing;
            document.getElementById('recaptionAllBtn').disabled = !hasCaptions || state.processing;
            document.getElementById('applyPrefixBtn').disabled = !hasImages || state.processing;
            document.getElementById('findReplaceBtn').disabled = !hasCaptions || state.processing;
            document.getElementById('exportFolderBtn').disabled = !hasImages || state.processing;
            document.getElementById('exportIndividualBtn').disabled = !hasImages || state.processing;
            document.getElementById('exportZipBtn').disabled = !hasImages || state.processing;
            document.getElementById('clearAllBtn').disabled = !hasImages || state.processing;
        }

        function removeImage(id) {
            state.images = state.images.filter(img => img.id !== id);
            renderImages();
            if (state.images.length === 0) {
                uploadZone.style.display = 'block';
            }
        }

        function showStatus(message, type = 'info') {
            statusMessage.textContent = message;
            statusMessage.className = `status-message ${type}`;
            statusMessage.style.display = 'block';
            setTimeout(() => {
                statusMessage.style.display = 'none';
            }, 5000);
        }

        function updateProgress(current, total) {
            const percent = (current / total) * 100;
            progressFill.style.width = percent + '%';
        }

        async function captionSingle(id) {
            const image = state.images.find(img => img.id === id);
            if (!image) return;

            const provider = apiProvider.value;
            
            // Validate credentials based on provider
            if (provider === 'n8n') {
                const url = n8nUrl.value.trim();
                const token = n8nToken.value.trim();
                if (!url || !token) {
                    showStatus('Please enter n8n webhook URL and Bearer token', 'error');
                    return;
                }
            } else {
                const key = apiKey.value.trim();
                if (!key) {
                    showStatus('Please enter an API key', 'error');
                    return;
                }
            }

            try {
                const caption = await generateCaption(image.dataUrl);
                image.caption = formatCaption(caption);
                renderImages();
                showStatus('Caption generated successfully!', 'success');
            } catch (error) {
                showStatus('Error generating caption: ' + error.message, 'error');
            }
        }

        async function captionAll() {
            const provider = apiProvider.value;
            
            // Validate credentials based on provider
            if (provider === 'n8n') {
                const url = n8nUrl.value.trim();
                const token = n8nToken.value.trim();
                if (!url || !token) {
                    showStatus('Please enter n8n webhook URL and Bearer token', 'error');
                    return;
                }
            } else {
                const key = apiKey.value.trim();
                if (!key) {
                    showStatus('Please enter an API key', 'error');
                    return;
                }
            }

            if (state.images.length === 0) return;

            state.processing = true;
            updateButtonStates();
            progressBar.style.display = 'block';
            
            let completed = 0;
            let skipped = 0;
            const total = state.images.length;

            for (const image of state.images) {
                // Skip images that already have captions
                if (image.caption && image.caption.trim()) {
                    skipped++;
                    completed++;
                    updateProgress(completed, total);
                    continue;
                }
                
                try {
                    const caption = await generateCaption(image.dataUrl);
                    image.caption = formatCaption(caption);
                    completed++;
                    updateProgress(completed, total);
                    renderImages();
                } catch (error) {
                    console.error('Error captioning image:', error);
                    showStatus(`Error on image ${completed + 1}: ${error.message}`, 'error');
                }
            }

            state.processing = false;
            progressBar.style.display = 'none';
            updateButtonStates();
            
            const captioned = completed - skipped;
            showStatus(`‚úÖ Captioned ${captioned} images, skipped ${skipped} existing captions!`, 'success');
        }

        async function recaptionAll() {
            if (!confirm('This will replace ALL existing captions with new AI-generated captions. Continue?')) {
                return;
            }

            const provider = apiProvider.value;
            
            // Validate credentials based on provider
            if (provider === 'n8n') {
                const url = n8nUrl.value.trim();
                const token = n8nToken.value.trim();
                if (!url || !token) {
                    showStatus('Please enter n8n webhook URL and Bearer token', 'error');
                    return;
                }
            } else {
                const key = apiKey.value.trim();
                if (!key) {
                    showStatus('Please enter an API key', 'error');
                    return;
                }
            }

            if (state.images.length === 0) return;

            state.processing = true;
            updateButtonStates();
            progressBar.style.display = 'block';
            
            let completed = 0;
            const total = state.images.length;

            for (const image of state.images) {
                try {
                    const caption = await generateCaption(image.dataUrl);
                    image.caption = formatCaption(caption);
                    completed++;
                    updateProgress(completed, total);
                    renderImages();
                } catch (error) {
                    console.error('Error captioning image:', error);
                    showStatus(`Error on image ${completed + 1}: ${error.message}`, 'error');
                }
            }

            state.processing = false;
            progressBar.style.display = 'none';
            updateButtonStates();
            showStatus(`‚úÖ Re-captioned all ${completed} images!`, 'success');
        }

        function openFindReplace() {
            document.getElementById('findReplaceModal').classList.add('active');
        }

        function executeFindReplace() {
            const findText = document.getElementById('findText').value;
            const replaceText = document.getElementById('replaceText').value;
            const caseSensitive = document.getElementById('caseSensitive').checked;
            
            if (!findText) {
                alert('Please enter text to find');
                return;
            }
            
            let replacedCount = 0;
            
            state.images.forEach(img => {
                if (img.caption) {
                    const flags = caseSensitive ? 'g' : 'gi';
                    const regex = new RegExp(findText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), flags);
                    
                    if (regex.test(img.caption)) {
                        img.caption = img.caption.replace(regex, replaceText);
                        replacedCount++;
                    }
                }
            });
            
            renderImages();
            closeModal('findReplaceModal');
            
            if (replacedCount > 0) {
                showStatus(`‚úÖ Replaced text in ${replacedCount} captions!`, 'success');
            } else {
                showStatus('No matches found', 'info');
            }
        }

        async function generateCaption(imageData) {
            const provider = apiProvider.value;
            const style = captionStyle.value;
            const prompt = getCaptionPrompt(style);

            if (provider === 'n8n') {
                return await generateCaptionN8N(imageData, prompt);
            } else if (provider === 'openrouter') {
                const key = apiKey.value.trim();
                const selectedModel = model.value;
                return await generateCaptionOpenRouter(imageData, key, selectedModel, prompt);
            } else if (provider === 'openai') {
                const key = apiKey.value.trim();
                const selectedModel = model.value;
                return await generateCaptionOpenAI(imageData, key, selectedModel, prompt);
            } else if (provider === 'replicate') {
                const key = apiKey.value.trim();
                const selectedModel = model.value;
                return await generateCaptionReplicate(imageData, key, selectedModel, prompt);
            }
        }

        function getCaptionPrompt(style) {
            // Use custom prompt if available
            if (state.customPrompts[style]) {
                return state.customPrompts[style];
            }

            // Otherwise use default
            return defaultPrompts[style];
        }

        async function generateCaptionOpenRouter(imageData, key, selectedModel, prompt) {
            // Validate API key
            if (!key || key.trim() === '') {
                throw new Error('OpenRouter API key is required');
            }

            // Use custom model if "custom" is selected
            let modelToUse = selectedModel;
            if (selectedModel === 'custom') {
                modelToUse = customModel.value.trim();
                if (!modelToUse) {
                    throw new Error('Please enter a custom model name');
                }
            }

            // Ensure key doesn't have extra whitespace or 'Bearer' prefix
            const cleanKey = key.trim().replace(/^Bearer\s+/i, '');
            
            const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${cleanKey}`,
                    'Content-Type': 'application/json',
                    'HTTP-Referer': window.location.origin,
                    'X-Title': 'LoRA Caption Tool'
                },
                body: JSON.stringify({
                    model: modelToUse,
                    messages: [
                        {
                            role: 'user',
                            content: [
                                {
                                    type: 'text',
                                    text: prompt
                                },
                                {
                                    type: 'image_url',
                                    image_url: {
                                        url: imageData
                                    }
                                }
                            ]
                        }
                    ],
                    max_tokens: 500
                })
            });

            if (!response.ok) {
                let errorMessage = `API request failed (${response.status})`;
                try {
                    const error = await response.json();
                    errorMessage = error.error?.message || error.message || errorMessage;
                } catch (e) {
                    const errorText = await response.text();
                    errorMessage = errorText || errorMessage;
                }
                throw new Error(errorMessage);
            }

            const data = await response.json();
            
            if (!data.choices || !data.choices[0] || !data.choices[0].message) {
                throw new Error('Invalid response format from OpenRouter API');
            }
            
            return data.choices[0].message.content;
        }

        async function generateCaptionOpenAI(imageData, key, selectedModel, prompt) {
            // Validate API key
            if (!key || key.trim() === '') {
                throw new Error('OpenAI API key is required');
            }

            // Ensure key doesn't have extra whitespace or 'Bearer' prefix
            const cleanKey = key.trim().replace(/^Bearer\s+/i, '');
            
            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${cleanKey}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    model: selectedModel,
                    messages: [
                        {
                            role: 'user',
                            content: [
                                {
                                    type: 'text',
                                    text: prompt
                                },
                                {
                                    type: 'image_url',
                                    image_url: {
                                        url: imageData
                                    }
                                }
                            ]
                        }
                    ],
                    max_tokens: 500
                })
            });

            if (!response.ok) {
                let errorMessage = `API request failed (${response.status})`;
                try {
                    const error = await response.json();
                    errorMessage = error.error?.message || error.message || errorMessage;
                } catch (e) {
                    const errorText = await response.text();
                    errorMessage = errorText || errorMessage;
                }
                throw new Error(errorMessage);
            }

            const data = await response.json();
            
            if (!data.choices || !data.choices[0] || !data.choices[0].message) {
                throw new Error('Invalid response format from OpenAI API');
            }
            
            return data.choices[0].message.content;
        }

        async function generateCaptionN8N(imageData, prompt) {
            const url = n8nUrl.value.trim();
            const token = n8nToken.value.trim();
            
            // Extract base64 data (remove data:image/...;base64, prefix)
            const base64Image = imageData.split(',')[1];
            const mimeType = imageData.split(';')[0].split(':')[1];
            
            const response = await fetch(url, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    image: base64Image,
                    imageData: imageData,
                    mimeType: mimeType,
                    prompt: prompt,
                    captionStyle: captionStyle.value
                })
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`n8n workflow failed: ${response.status} - ${errorText}`);
            }

            const data = await response.json();
            
            // Support multiple response formats from n8n
            return data.caption || data.text || data.description || data.output || JSON.stringify(data);
        }

        async function generateCaptionReplicate(imageData, key, selectedModel, prompt) {
            throw new Error('Replicate integration requires server-side implementation. Use OpenRouter or OpenAI for now.');
        }

        function formatCaption(caption) {
            let formatted = caption.trim();
            
            const trigger = triggerWord.value.trim();
            const prefixText = prefix.value.trim();
            
            const parts = [];
            if (trigger) parts.push(trigger);
            if (prefixText) parts.push(prefixText);
            
            if (parts.length > 0) {
                // Add trigger and prefix at the start of the structured caption
                return parts.join(', ') + '\n\n' + formatted;
            }
            
            return formatted;
        }

        function applyPrefixToAll() {
            const prefixText = prefix.value.trim();
            const trigger = triggerWord.value.trim();
            
            if (!prefixText && !trigger) {
                showStatus('Please enter a prefix or trigger word', 'error');
                return;
            }

            state.images.forEach(img => {
                if (img.caption) {
                    const parts = [];
                    if (trigger) parts.push(trigger);
                    if (prefixText) parts.push(prefixText);
                    
                    const currentPrefix = parts.join(', ');
                    
                    // Remove existing prefix if present
                    const lines = img.caption.split('\n');
                    if (lines[0].includes(',') && !lines[0].includes(':')) {
                        // Likely already has a prefix line
                        lines[0] = currentPrefix;
                        img.caption = lines.join('\n');
                    } else {
                        // Add new prefix
                        img.caption = currentPrefix + '\n\n' + img.caption;
                    }
                }
            });

            renderImages();
            showStatus('Prefix applied to all captions!', 'success');
        }

        // EXPORT METHOD 1: File System Access API (NO WARNINGS - BEST METHOD)
        async function exportToFolder() {
            if (!supportsFileSystemAccess) {
                compatModal.classList.add('active');
                return;
            }

            if (state.images.length === 0) return;

            try {
                // Request directory access
                const dirHandle = await window.showDirectoryPicker({
                    mode: 'readwrite'
                });

                showStatus('Saving files to folder...', 'info');
                let saved = 0;

                for (const img of state.images) {
                    try {
                        // Save image file
                        const imgFileHandle = await dirHandle.getFileHandle(img.name, { create: true });
                        const imgWritable = await imgFileHandle.createWritable();
                        const imgBlob = await fetch(img.dataUrl).then(r => r.blob());
                        await imgWritable.write(imgBlob);
                        await imgWritable.close();

                        // Save caption txt file
                        const txtName = img.name.replace(/\.[^/.]+$/, '') + '.txt';
                        const txtFileHandle = await dirHandle.getFileHandle(txtName, { create: true });
                        const txtWritable = await txtFileHandle.createWritable();
                        await txtWritable.write(img.caption || '');
                        await txtWritable.close();

                        saved++;
                    } catch (error) {
                        console.error('Error saving file:', error);
                    }
                }

                showStatus(`‚úÖ Successfully saved ${saved * 2} files to folder! NO security warnings!`, 'success');
            } catch (error) {
                if (error.name === 'AbortError') {
                    showStatus('Export cancelled', 'info');
                } else {
                    showStatus('Error exporting to folder: ' + error.message, 'error');
                }
            }
        }

        // EXPORT METHOD 2: Individual Downloads
        async function exportIndividual() {
            if (state.images.length === 0) return;

            showStatus(`Starting download of ${state.images.length * 2} files...`, 'info');
            
            for (let i = 0; i < state.images.length; i++) {
                const img = state.images[i];
                
                // Download image
                const imgLink = document.createElement('a');
                imgLink.href = img.dataUrl;
                imgLink.download = img.name;
                imgLink.click();
                
                // Download caption txt
                const txtName = img.name.replace(/\.[^/.]+$/, '') + '.txt';
                const txtBlob = new Blob([img.caption || ''], { type: 'text/plain' });
                const txtUrl = URL.createObjectURL(txtBlob);
                const txtLink = document.createElement('a');
                txtLink.href = txtUrl;
                txtLink.download = txtName;
                txtLink.click();
                URL.revokeObjectURL(txtUrl);
                
                if (i < state.images.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
            }
            
            showStatus('All files downloaded! Check your Downloads folder.', 'success');
        }

        // EXPORT METHOD 3: ZIP (May trigger warnings)
        async function exportZip() {
            if (state.images.length === 0) return;

            const zip = new JSZip();
            
            state.images.forEach(img => {
                const base64Data = img.dataUrl.split(',')[1];
                zip.file(img.name, base64Data, { base64: true });
                
                const txtName = img.name.replace(/\.[^/.]+$/, '') + '.txt';
                zip.file(txtName, img.caption || '');
            });

            const blob = await zip.generateAsync({ type: 'blob' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'lora_training_dataset.zip';
            a.click();
            URL.revokeObjectURL(url);
            
            showStatus('‚ö†Ô∏è ZIP downloaded. If Windows blocks it: Right-click ZIP ‚Üí Properties ‚Üí Check "Unblock" ‚Üí Extract. Or use "Save to Folder" instead.', 'warning');
        }

        function clearAll() {
            if (confirm('Are you sure you want to clear all images and captions?')) {
                state.images = [];
                renderImages();
                uploadZone.style.display = 'block';
                showStatus('All images cleared', 'info');
            }
        }

        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('active');
        }

        function openPromptEditor() {
            const style = captionStyle.value;
            const currentPrompt = state.customPrompts[style] || defaultPrompts[style];
            
            // Update modal
            promptEditor.value = currentPrompt;
            const styleNames = {
                natural: 'Natural Language',
                tags: 'Danbooru Tags',
                hybrid: 'Hybrid (Desc + Tags)'
            };
            promptStyleLabel.textContent = styleNames[style];
            
            promptModal.classList.add('active');
        }

        function savePrompt() {
            const style = captionStyle.value;
            const newPrompt = promptEditor.value.trim();
            
            if (!newPrompt) {
                alert('Prompt cannot be empty');
                return;
            }
            
            state.customPrompts[style] = newPrompt;
            closeModal('promptModal');
            showStatus(`Custom prompt saved for ${captionStyle.options[captionStyle.selectedIndex].text}!`, 'success');
        }

        function resetPrompt() {
            const style = captionStyle.value;
            state.customPrompts[style] = null;
            promptEditor.value = defaultPrompts[style];
            showStatus('Prompt reset to default', 'info');
        }

        // Event listeners for prompt editor
        editPromptBtn.addEventListener('click', openPromptEditor);
        savePromptBtn.addEventListener('click', savePrompt);
        resetPromptBtn.addEventListener('click', resetPrompt);

        // Close modal when clicking outside
        promptModal.addEventListener('click', (e) => {
            if (e.target === promptModal) {
                closeModal('promptModal');
            }
        });

        compatModal.addEventListener('click', (e) => {
            if (e.target === compatModal) {
                closeModal('compatModal');
            }
        });

        document.getElementById('findReplaceModal').addEventListener('click', (e) => {
            if (e.target === document.getElementById('findReplaceModal')) {
                closeModal('findReplaceModal');
            }
        });

        // Event listeners for buttons
        document.getElementById('captionAllBtn').addEventListener('click', captionAll);
        document.getElementById('recaptionAllBtn').addEventListener('click', recaptionAll);
        document.getElementById('applyPrefixBtn').addEventListener('click', applyPrefixToAll);
        document.getElementById('findReplaceBtn').addEventListener('click', openFindReplace);
        document.getElementById('executeFindReplaceBtn').addEventListener('click', executeFindReplace);
        document.getElementById('exportFolderBtn').addEventListener('click', exportToFolder);
        document.getElementById('exportIndividualBtn').addEventListener('click', exportIndividual);
        document.getElementById('exportZipBtn').addEventListener('click', exportZip);
        document.getElementById('clearAllBtn').addEventListener('click', clearAll);

        // Initialize
        renderImages();

        // Show info on first load
        if (supportsFileSystemAccess) {
            setTimeout(() => {
                showStatus('üí° Tip: Use "Save to Folder" for zero security warnings! Your browser supports it.', 'success');
            }, 1000);
        } else {
            setTimeout(() => {
                showStatus('‚ÑπÔ∏è Your browser doesn\'t support "Save to Folder". Use "Download All Files" instead.', 'info');
            }, 1000);
        }
    </script>
</body>
</html>
